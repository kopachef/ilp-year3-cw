package uk.ac.ed.inf;

import com.mapbox.geojson.*;
import uk.ac.ed.inf.algorithm.Graph;
import uk.ac.ed.inf.algorithm.Node;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Date;
import java.util.*;
import java.util.List;

import static java.util.stream.Collectors.flatMapping;
import static java.util.stream.Collectors.toList;

public class DeliveryPlanner {

    /**
     * Delivery Planner manages drones delivery by keeping track of the following:
     *
     *   - Creates an instance of the OrderDeliveryWorker which is used to get FoodOrders.
     *   - Checking if the drone can fulfill and order before deploying it(including checking that it will have
     *      enough battery capacity to get back home)
     *   - Updating the FoodOrder Queue based on the drone's location.
     *   - Generating the delivery path as json output file.
     *   - Keeping a hashmap of the partial delivery path to avoid recalculation.
     */

    private final Date deliveryDate;
    private LinkedList<FoodOrder> deliverableOrders = new LinkedList<>();
    private HashMap<FoodOrder, List<Node>> deliveryPaths = new HashMap<>();
    private Drone drone = new Drone(1500);
    private List<Node> pathToHome = new LinkedList<>();
    private OrderDeliveryWorker orderDeliveryWorker;
    private double totalOrderValue = 0;
    private int totalOrderCount;
    //TODO remove ony for graphing purposes
    List<Node> pickupNodes = new ArrayList<>();
    private Graph graph =
      new Graph(
          Settings.getDefaultNorthWestBound().longitude,
          Settings.getDefaultNorthWestBound().latitude,
          Settings.getDefaultSouthEastBound().longitude,
          Settings.getDefaultSouthEastBound().latitude,
          Settings.GRID_GRANULARITY);

    public DeliveryPlanner(Date deliveryDate) {
        this.deliveryDate = deliveryDate;
        this.orderDeliveryWorker = new OrderDeliveryWorker(drone, deliveryDate);
        this.orderDeliveryWorker.populateFoodOrders();
        totalOrderCount = orderDeliveryWorker.getFoodOrderQueueSize();
        updateFoodDeliveryList();
    }


    private void updateFoodDeliveryList() {
        boolean canDeliver = true;
        while(canDeliver && orderDeliveryWorker.getFoodOrderQueueSize() > 0) {
            orderDeliveryWorker.updateFoodOrders(drone, orderDeliveryWorker.getFoodOrderQueue());
            FoodOrder foodOrder = orderDeliveryWorker.getFoodOrder();
            graph.resetNodeUsages();
            List<LongLat> pickUpLocations = foodOrder.getPickUpLocations();
            LongLat deliveryLongLat = foodOrder.getDeliveryLocationLongLat();
            LongLat startLocation = drone.getCurrentPosition();
            List<LongLat> visitLocations = new ArrayList<>();
            visitLocations.add(startLocation);
            visitLocations.addAll(pickUpLocations);
            List<Node> pathToClient = new ArrayList<>();
            List<List<Node>> concat = new ArrayList<>();
            for (LongLat longlat : pickUpLocations) {
                List<Node> path = graph.getShortestPath(startLocation, longlat);
                setLastNodeUsage(path, Node.NodeUsage.PICKUP);
                concat.add(path);
                //path.remove(0);
                pathToClient.addAll(path);
                startLocation = longlat;
                Node placeHolderNode  = new Node(0,0);
                placeHolderNode.setLongLat(longlat);
                if(!pickupNodes.contains(placeHolderNode)) {
                    pickupNodes.add(placeHolderNode);
                }
            }
            List<Node> testPath = new ArrayList<>();
            for(int i = 0; i < visitLocations.size() - 1; i++) {
                testPath.addAll(graph.getShortestPath(visitLocations.get(i), visitLocations.get(i+1)));
            }


            List<Node> pathToFinalStation = graph.getShortestPath(startLocation, deliveryLongLat);
            for(int i = 1; i < concat.size()-1; i++){
                //System.out.println("seq dist: " + concat.get(i-1).get(concat.get(i-1).size()-1).getLongLat().distanceTo(concat.get(i).get(0).getLongLat())/Settings.getDefaultMovementStepDistance());
            }
            setLastNodeUsage(pathToFinalStation, Node.NodeUsage.DROPOFF);
            //pathToFinalStation.remove(0);
            pathToClient.addAll(pathToFinalStation);
            List<Node> pathFromClientToHome =
                    graph.getShortestPath(deliveryLongLat, Settings.getDefaultHomeLocation());
            //graph.printDistanceBetweenNodes(pathFromClientToHome);


            //graph.printDistanceBetweenNodes(pathFromClientToHome);

            //TODO can get rid of this print statement
            graph.printDistanceBetweenNodes(testPath);

            //TODO modify this to be more reflective of what the dor eisactually doiubg.
            double travelDistance =
                    graph.distanceBetweenNodes(pathToClient) +
                    graph.distanceBetweenNodes(pathFromClientToHome);
            int estimatedBatteryUsage = drone.calculateMovementStepCost(travelDistance);
            if(drone.getBatteryLevel() - estimatedBatteryUsage > 0) {
                //executeMoves(drone, pathToClient);
                drone.setCurrentPosition(pathToClient.get(pathToClient.size()-1).getLongLat());
                deliverableOrders.add(foodOrder);
                deliveryPaths.put(foodOrder, pathToClient);
                pathToHome = pathFromClientToHome;
                //System.out.println("can deliver drone loc: " + drone.getCurrentPosition().calculateBearing(pathToClient.get(pathToClient.size()-1).getLongLat()));

            } else {
                canDeliver = false;
                setLastNodeUsage(pathToHome, Node.NodeUsage.HOME);
                executeMoves(drone, pathToHome);
                //System.out.println(drone.getCurrentPosition() + "state is: " + drone.getDroneState());
            }
        }
    }
    public void executeMoves(Drone drone, List<Node> pathNodes){
        for(Node node: pathNodes) {
            switch(node.getUsage()) {
                case PICKUP:
                    drone.hoverDrone();
                    drone.loadItems();
                    drone.flyDrone();
                    //System.out.println("picked order");
                    break;
                case DROPOFF:
                    drone.hoverDrone();
                    drone.unloadItems();
                    drone.flyDrone();
                    //System.out.println("dropped order");
                    break;
                case HOME:
                    drone.returnToHome();
                    //System.out.println("got home safe");
                    break;
                default:
                    drone.moveTo(node.getLongLat());
                    //System.out.println("ordinary move");
          }
          }
        }

    public void setLastNodeUsage(List<Node> nodes, Node.NodeUsage usage) {
        nodes.get(nodes.size() - 1).setNodeUsage(usage);
    }
    public void generatePathMap() {
        FeatureCollection featureCollection = GeoJsonManager.createFeatureCollection(convertPathsToGeojsonFeatures());
        String filePrefix = "src/main/java/uk/ac/ed/inf/";
        try {
            FileWriter myWriter = new FileWriter(filePrefix + "geojson-" + String.valueOf(deliveryDate) + ".geojson");
            myWriter.write(featureCollection.toJson());
            myWriter.close();
            System.out.println("Successfully wrote to the file.");
        } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }

    }

    public List<Feature> convertPathsToGeojsonFeatures() {
        List<Feature> features = new ArrayList<>();
        features.addAll(GeoJsonManager.getRestrictedAreasFeatures());
//        features.addAll(
//                GeoJsonManager.generatePointsFromNodes(pickupNodes).stream()
//                .map(x -> Feature.fromGeometry((Geometry) x))
//                .collect(toList()));
        int counter = 0;
        for(FoodOrder foodOrder : deliverableOrders) {
            Point deliveryPoint = GeoJsonManager.createPointFromLongLat(foodOrder.getDeliveryLocationLongLat());
            LineString lineString =
                    LineString.fromLngLats(GeoJsonManager.generatePointsFromNodes(deliveryPaths.get(foodOrder)));
            if (counter == 0) {
                //System.out.println(foodOrder.getOrderItems() + "\n" + foodOrder.getDeliveryCost()+"\n" + foodOrder.getDeliveryW3wAddress() + "\n" + foodOrder.getDeliveryLocationLongLat());
                features.add(Feature.fromGeometry((Geometry) deliveryPoint));
                features.add(Feature.fromGeometry((Geometry) lineString));
            }
            totalOrderValue += foodOrder.getDeliveryCost();
            counter += 1;

            //System.out.println("Delivery no: " +counter+"/"+ deliverableOrders.size()+"\nMonetary value: " +
            //        100*totalOrderValue/orderDeliveryWorker.getTotalOrderValue());
        }
        //Add final path to home and home marker.
        //Point homeMarker = GeoJsonManager.createPointFromLongLat(Settings.getDefaultHomeLocation());
        LineString lineStringToHome = LineString.fromLngLats(GeoJsonManager.generatePointsFromNodes(pathToHome));
        //features.add(Feature.fromGeometry((Geometry) lineStringToHome));
        //features.add(Feature.fromGeometry((Geometry) homeMarker));
        Point homeMarker = GeoJsonManager.createPointFromLongLat(drone.getCurrentPosition());
        //Point test = GeoJsonManager.createPointFromLongLat(drone.getCurrentPosition().nextPosition(10));
        //LineString ls = LineString.fromLngLats(List.of(homeMarker, test));
        //features.add(Feature.fromGeometry((Geometry) ls));
        //features.add(Feature.fromGeometry((Geometry) test));
        //features.add(Feature.fromGeometry((Geometry) homeMarker));
        return features;
    }

    public LinkedList<FoodOrder> getDeliverableOrders() {
        return deliverableOrders;
    }

    public HashMap<FoodOrder, List<Node>> getDeliveryPaths() {
        return deliveryPaths;
    }
}




------------------------------------------------------------------------------------------------------------------------------


//    List<DatabaseIO.Delivery> deliveries = deliveryPlanner.getDeliveries();
//    List<DatabaseIO.FlightPath> flightPaths = deliveryPlanner.getFlightPaths();

//    for(DatabaseIO.Delivery d : deliveries) {
//      //System.out.println(d.orderNo + "   " + d.deliveredTo + "     " + d.costInPence);
//    }
//
//    for(DatabaseIO.FlightPath f : flightPaths) {
//      //System.out.println(f.angle + "     " + f.orderNo);
//    }

//    List<Point> ls = new ArrayList<>();
//    ls.add(Point.fromLngLat(flightPaths.get(0).fromLongitude, flightPaths.get(0).fromLatitude));
//    for(DatabaseIO.FlightPath fp : flightPaths) {
//      ls.add(Point.fromLngLat(fp.toLongitude, fp.toLatitude));
//    }

    /**
     * qworkable solution for the mean tinme. still getting netrsectiung edges.
     */
    //List<Node> path = g.getShortestPath(dest2, start);


//    for (int j = 0; j < path.size()-2; j++) {
//      for (int i = j; i < path.size() - 2; i++) {
//        //        List<Point> pts =
//        //            GeoJsonManager.generatePointsFromNodes(
//        //                Arrays.asList(path.get(j), path.get(i + 1), path.get(i + 2),
//        // path.get(j)));
//        //        LineString ls = LineString.fromLngLats(pts);
//        //        Polygon p = Polygon.fromOuterInner(ls);
//        if (GeoJsonManager.lineOfSight(path.get(j), path.get(i+2))) {
//          break;
//        } else {
//          if(path.get(i+1).getUsage() == Node.NodeUsage.ORDINARY) {
//
//            //feats.add(Feature.fromGeometry((Geometry) ls));
//            //feats.add(Feature.fromGeometry((Geometry) p));
//            path.remove(i+1);
//          }
//        }
//
//        // System.out.println(GeoJsonManager.intersectsRestrictedArea(p));
//      }
//    }
//    List<Point> pathPoints = GeoJsonManager.generatePointsFromNodes(path);
//    feats.add(Feature.fromGeometry((Geometry) LineString.fromLngLats(pathPoints)));
//
//    for (int j = 0; j < path.size()-2; j++) {
//      for (int i = j; i < path.size() - 2; i++) {
//        List<Point> pts =
//                GeoJsonManager.generatePointsFromNodes(
//                        Arrays.asList(path.get(j), path.get(i + 1), path.get(i + 2), path.get(j)));
//        LineString ls = LineString.fromLngLats(pts);
//        Polygon p = Polygon.fromOuterInner(ls);
//        if (GeoJsonManager.intersectsRestrictedArea(p)) {
//          break;
//        } else {
//          if(path.get(i+1).getUsage() == Node.NodeUsage.ORDINARY) {
//            //feats.add(Feature.fromGeometry((Geometry) ls));
//            //feats.add(Feature.fromGeometry((Geometry) p));
//            path.remove(i+1);
//
//          }
//        }
//       }}

//        // System.out.println(GeoJsonManager.intersectsRestrictedArea(p));
//      }
//    }

    //g.printDistanceBetweenNodes(path);


    //g.printDistanceBetweenNodes(path);

//    for (int i = 0; i < path.size() - 2; i++) {
//        List<Point> pts =
//            GeoJsonManager.generatePointsFromNodes(
//                Arrays.asList(path.get(i), path.get(i + 1), path.get(i + 2), path.get(i)));
//        LineString ls = LineString.fromLngLats(pts);
//        Polygon p = Polygon.fromOuterInner(ls);
//        if (!GeoJsonManager.intersectsRestrictedArea(p)) {
//          path.remove(i+1);
//          //feats.add(Feature.fromGeometry((Geometry) p));
//        }
//
//        // System.out.println(GeoJsonManager.intersectsRestrictedArea(p));
//      }

    //System.out.println(FeatureCollection.fromFeature(Feature.fromGeometry((Geometry) ls)).toJson());
    // System.out.println(deliveryPlanner.getDeliveryPaths());

    //    List<Node> path = g.getShortestPath(devloc, dest2);
    //    List<Point> pts = GeoJsonManager.generatePointsFromNodes(path);
    //    LineString ls = LineString.fromLngLats(pts);
    //    Feature feats = Feature.fromGeometry((Geometry) ls);
    //
    //    List<Point> pt = GeoJsonManager.generatePointsFromNodes(g.getAllNodes());
    //    List<Feature> feats2 = pt.stream().map(x -> Feature.fromGeometry((Geometry)
    // x)).collect(toList());
    //    feats2.add(feats);
    //    List<Feature> res = GeoJsonManager.getRestrictedAreasFeatures();
    //    feats2.addAll(res);
    //
    //    FeatureCollection fc = FeatureCollection.fromFeatures(feats2);
    //
    //    //g.printDistanceBetweenNodes(path);
    //    for(int i = 1;i < path.size(); i++) {
    //      //System.out.println("Node angle: " + path.get(i-1).calculateAngleTo(path.get(i))+
    // "LongLat Angle: " + path.get(i-1).getLongLat().calculateBearing(path.get(i).getLongLat()));
    //    }
    //    //System.out.println(fc.toJson());
    //    }

//    List<Node> path = deliveryPlanner.getAPath();
//    System.out.println(path.size());
//    List<Feature> feats = GeoJsonManager.getRestrictedAreasFeatures();
//
//    int smoothGranularity = 9;
//    for (int j = 0; j < path.size() - smoothGranularity; j++) {
//      for (int i = j; i < path.size() - smoothGranularity; i++) {
//        List<Point> pts =
//                GeoJsonManager.generatePointsFromNodes(
//                        Arrays.asList(path.get(j), path.get(i + 1), path.get(i + smoothGranularity), path.get(j)));
//        LineString ls = LineString.fromLngLats(pts);
//        Polygon p = Polygon.fromLngLats(Collections.singletonList(pts));
//        if (GeoJsonManager.intersectsRestrictedArea(p)) {
//          break;
//        } else {
//          if(path.get(i+1).getUsage() == Node.NodeUsage.ORDINARY) {
//            //feats.add(Feature.fromGeometry((Geometry) ls));
//            //feats.add(Feature.fromGeometry((Geometry) p));
//            path.remove(i+1);
//
//          }
//        }
//
//        // System.out.println(GeoJsonManager.intersectsRestrictedArea(p));
//      }
//    }



//    double angleDebt = 0;
//    double distanceDebt = 0;
//    boolean previousNodeSet = true;
//
//    for (int i = 0; i < path.size() - 1; i++) {
//      Node curr = path.get(i);
//      Node next = path.get(i + 1);
//      double bearing = curr.getLongLat().calculateBearing(next.getLongLat());
//      double distance = curr.getLongLat().distanceTo(next.getLongLat());
//
//      int roundedAngle = Utils.roundOffToNearest10th(bearing);
//      double roundedDistance =
//          Utils.roundOffToNearestMultiple(distance, Settings.getDefaultMovementStepDistance());
//
//      int stepCount = (int) (roundedDistance / Settings.getDefaultMovementStepDistance());
//
//      // System.out.println("angle: " + bearing + " rounded angle: " + roundedAngle + " distance: "
//      // + distance + "   roudnedDist: " + roundedDistance + "step count: " + stepCount);
//
//       //angl;e projection options
//            int topAngle = 0;
//            int bottomAngle = 0;
//
//            if(roundedAngle > bearing) {
//              topAngle = roundedAngle;
//              bottomAngle = topAngle - 10;
//            } else {
//              topAngle = roundedAngle + 10;
//              bottomAngle = roundedAngle;
//            }
//      LongLat posUpper = curr.getLongLat();
//      LongLat posLower = curr.getLongLat();
//
//      while (stepCount > 0) {
//        posUpper = posUpper.nextPosition(roundedAngle);
//        posLower = posLower.nextPosition(bottomAngle);
//        stepCount -= 1;
//      }
//
//      //next.setLongLat(posLower);
//      //reassignment
//      if(next.getUsage() == Node.NodeUsage.ORDINARY) {
//        if(!GeoJsonManager.isInRestrictedArea(posUpper) && posUpper.isConfined() && !GeoJsonManager.crossesRestricedArea(curr.getLongLat(), posUpper)) {
//          next.setLongLat(posUpper);
//        } else if(!GeoJsonManager.isInRestrictedArea(posLower) && posLower.isConfined() && !GeoJsonManager.crossesRestricedArea(curr.getLongLat(), posLower)) {
//          next.setLongLat(posLower);
//        } else {
//          previousNodeSet = false;
//        }
//      } else {
//        LongLat trueLocation = deliveryPlanner.getMapping().get(next.getLongLat());
//        if(!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), posUpper)) {
//          next.setLongLat(posUpper);
//        } else if(!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), posLower)) {
//          next.setLongLat(posLower);
//        } else {
//          System.out.println("Could nopt find alternate for ordinary node:  " + i+1 );
//          Node rebound = new Node(0,0);
//          double longitude = (curr.getLongLat().longitude + next.getLongLat().longitude)/2;
//          double latitude = (curr.getLongLat().latitude + next.getLongLat().latitude)/2;
//
//          LongLat mid = new LongLat(longitude, latitude);
//          LongLat upperProjection = mid;
//          LongLat lowerProjection = mid;
//
//          boolean reboundSet = false;
//
//          while (!reboundSet) {
//            upperProjection = upperProjection.nextPosition((roundedAngle - 90) % 360);
//            lowerProjection = lowerProjection.nextPosition((roundedAngle + 90) % 360);
//
//            if (!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), upperProjection)
//                && !GeoJsonManager.crossesRestricedArea(upperProjection, next.getLongLat())) {
//              rebound.setLongLat(upperProjection);
//              rebound.setNodeUsage(Node.NodeUsage.ORDINARY);
//              path.add(i + 1, rebound);
//              reboundSet = true;
//            } else if (!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), lowerProjection)
//                    && !GeoJsonManager.crossesRestricedArea(lowerProjection, next.getLongLat())){
//              rebound.setLongLat(lowerProjection);
//              rebound.setNodeUsage(Node.NodeUsage.ORDINARY);
//              path.add(i + 1, rebound);
//              reboundSet = true;
//            }
//            previousNodeSet = false;
//          }
//        }
//      }
//    }




//    for(int i = 0; i < path.size(); i++)  {
//      if(path.get(i).getUsage() != Node.NodeUsage.ORDINARY) {
//        Node current = path.get(i);
//        LongLat oldLocation = current.getLongLat();
//        LongLat trueLocation = deliveryPlanner.getMapping().get(oldLocation);
//        current.setLongLat(trueLocation);
//        path.set(i, current);
//      }
//    }
//
//    List<Node> path2 = new ArrayList<>(path);
//    HashMap<Node, Integer> idxLookUp = new HashMap<>();
//    for(int i = 0; i < path.size(); i++) {
//      idxLookUp.put(path2.get(i), i);
//    }
////
//    int cycle = 2;
//    while (cycle > 0) {
//      for (int j = 0; j < path.size() - 2; j++) {
//        if (!GeoJsonManager.crossesRestricedArea(path.get(j).getLongLat(), path.get(j + 2).getLongLat())
//                && (path.get(j + 1).getUsage() == Node.NodeUsage.ORDINARY)) {
//          path.remove(j + 1);
//        }
//      }
//      cycle -= 1;
//    }
////    System.out.println(path.size());
////
////
////    //path2.add(path.get(0));
//    double angleDebt = 0;
//    double distanceDebt = 0;
//
//    for (int i = 0; i < path.size() - 1; i++) {
//      Node curr = path.get(i);
//      Node next = path.get(i + 1);
//
//      double bearing = curr.getLongLat().calculateBearing(next.getLongLat()) + angleDebt;
//      double distance = curr.getLongLat().distanceTo(next.getLongLat()) + distanceDebt;
//
//      int roundedAngle = Utils.roundOffToNearest10th(bearing);
//      double roundedDistance =
//          Utils.roundOffToNearestMultiple(distance, Settings.getDefaultMovementStepDistance());
//      int stepCount = (int) (roundedDistance / Settings.getDefaultMovementStepDistance());
//
////      distanceDebt = distance - roundedDistance;
////      angleDebt = bearing - roundedAngle;
//
//      LongLat pos1 = curr.getLongLat();
//      LongLat pos2= curr.getLongLat();
//      LongLat pos3 = curr.getLongLat();
//      LongLat pos4 = curr.getLongLat();
//      LongLat pos5 = curr.getLongLat();
//      LongLat pos6 = curr.getLongLat();
//      LongLat pos7 = curr.getLongLat();
//      LongLat pos8 = curr.getLongLat();
//      LongLat pos9 = curr.getLongLat();
//      LongLat pos10 = curr.getLongLat();
//      LongLat pos11 = curr.getLongLat();
//      LongLat pos12 = curr.getLongLat();
//      LongLat pos13 = curr.getLongLat();
////////////      Node rebound = new Node(0, 0);
////////////
////////////      double longitude = (curr.getLongLat().longitude + next.getLongLat().longitude) / 2;
////////////      double latitude = (curr.getLongLat().latitude + next.getLongLat().latitude) / 2;
////////////
////////////      LongLat mid = new LongLat(longitude, latitude);
////////////      LongLat upperProjection = mid;
////////////      LongLat lowerProjection = mid;
////////////
////////////      boolean reboundSet = false;
////////////
////////////      if (path.get(i + 1).getUsage() != Node.NodeUsage.ORDINARY) {
////////////        while (!reboundSet) {
////////////          upperProjection = upperProjection.nextPosition((roundedAngle - 90) % 360);
////////////          lowerProjection = lowerProjection.nextPosition((roundedAngle + 90) % 360);
////////////
////////////          if (!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), upperProjection)
////////////              && !GeoJsonManager.crossesRestricedArea(upperProjection, next.getLongLat())) {
////////////            rebound.setLongLat(upperProjection);
////////////            rebound.setNodeUsage(Node.NodeUsage.ORDINARY);
////////////            path2.add(path.get(i));
////////////            path2.add(rebound);
////////////            reboundSet = true;
////////////          } else if (!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), lowerProjection)
////////////              && !GeoJsonManager.crossesRestricedArea(lowerProjection, next.getLongLat())) {
////////////            rebound.setLongLat(lowerProjection);
////////////            rebound.setNodeUsage(Node.NodeUsage.ORDINARY);
////////////            path2.add(path.get(i));
////////////            path.add(rebound);
////////////            reboundSet = true;
////////////          }
////////////        }
////////////      }
//    while(stepCount > 0){
//        pos1 = pos1.nextPosition(roundedAngle);
//        pos2 = pos2.nextPosition(roundedAngle + 10);
//        pos3 = pos3.nextPosition(roundedAngle - 10);
//        pos4 = pos4.nextPosition(roundedAngle + 20);
//        pos5 = pos5.nextPosition(roundedAngle - 20);
//        pos6 = pos6.nextPosition(roundedAngle + 30);
//        pos7 = pos7.nextPosition(roundedAngle - 30);
//        pos8 = pos8.nextPosition(roundedAngle + 40);
//        pos9 = pos9.nextPosition(roundedAngle - 40);
//        pos10 = pos10.nextPosition(roundedAngle + 50);
//        pos11 = pos11.nextPosition(roundedAngle - 50);
//        pos12 = pos12.nextPosition(roundedAngle + 60);
//        pos13 = pos13.nextPosition(roundedAngle - 60);
//        stepCount-=1;
//    }
//    List<LongLat> positions = Arrays.asList(pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9, pos10, pos11);
//
////    int counter = 5;
////    while(counter > 0 && GeoJsonManager.crossesRestricedArea(curr.getLongLat(), pos)){
////      pos = pos.nextPosition(roundedAngle);
////      counter+=1;
////    }
//      for(LongLat l : positions) {
//        if(!GeoJsonManager.crossesRestricedArea(curr.getLongLat(), l) && !GeoJsonManager.isInRestrictedArea(l)) {
//          next.setLongLat(l);
//          break;
//        }
//        if(l == pos13){
//          System.out.println("could not find any pos");
//        }
//      }
//
//      path2.set(i + 1, next);
//      path.set(i + 1, next);
//    }


//    for (int j = 0; j < path.size() - 2; j++) {
//      if (!GeoJsonManager.crossesRestricedArea(path.get(j).getLongLat(), path.get(j + 2).getLongLat())
//              && (path.get(j + 1).getUsage() == Node.NodeUsage.ORDINARY)
//              && (Utils.isWholeNumber(path.get(j).getLongLat().distanceTo(path.get(j+1).getLongLat())/Settings.getDefaultMovementStepDistance()))) {
//        path.remove(j + 1);
//      }
//    }

////////////
//    for (int i = 0; i < path2.size() - 1; i++) {
//      Node curr = path2.get(i);
//      Node next = path2.get(i + 1);
//
//      double bearing = curr.getLongLat().calculateBearing(next.getLongLat());
//      double distance = curr.getLongLat().distanceTo(next.getLongLat());
//
//      int roundedAngle = Utils.roundOffToNearest10th(bearing);
//      double roundedDistance =
//              Utils.roundOffToNearestMultiple(distance, Settings.getDefaultMovementStepDistance());
//      int stepCount = (int) (roundedDistance / Settings.getDefaultMovementStepDistance());
//
//      LongLat pos = curr.getLongLat();
//      while(stepCount > 0){
//        pos = pos.nextPosition(roundedAngle);
//        stepCount-=1;
//      }
//
//      path2.set(i+1, next);
//      next.setLongLat(pos);
//
//      path.set(i+1,next);
//    }
/////////////////
    //g.printDistanceBetweenNodes(path);
//    for(int i = 0; i<path.size()-1; i++){
//      if(GeoJsonManager.crossesRestricedArea(path.get(i).getLongLat(), path.get(i+1).getLongLat())){
//        Node curr = path.get(i);
//        Node next = path.get(i+1);
//        System.out.println("found a spamy: " + curr + "to : " + next);
//
//
//        List<Node> connectingPath = new ArrayList<>();
//        int start = idxLookUp.get(curr) + 1;
//        for(int j = start; j < path2.size(); j++){
//          if(path2.get(j) == next) {
//            break;
//          } else {
//            connectingPath.add(path2.get(j));
//          }
//        }
//        for(int j = connectingPath.size()-1; j >= 0; j--) {
//          path.add(i+1,connectingPath.get(j));
//        }
//      }
//    }